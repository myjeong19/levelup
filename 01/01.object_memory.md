# 객체가 메모리 참조하는 방법

## 힙객체 (HeapObject)

- HeapObject는 관리되는 힙의 메모리를 가르키는 포인터 (저장 공간을 가르키는 방향표 같은거)

  - 힙에 할당되는 모든 것의 슈퍼클래스임 (단군할아버지)
  - 마지막 비트가 1이라, 포인터를 사용하기전 해당 비트를 지워야함

- 컴퓨터 과학에서 포인터는 메모리에 있는 다른 값의 메모리 주소를 저장하는 객체 (지도)  
  메모리 위치를 참조하고 해당 위치에 저장된 값을 얻는 것을 포인터 역참조라함

  - 이 때, 포인터의 크기는 CPU 아키텍처, 컴파일러, OS 등을 포함한 여러 요소에 따라 달라짐
    - 일반적으로 크기는 OS의 단어 크기와 동일함
      - 32bit -> 4bite
      - 64bit -> 8bite

## Object

객체는 키-값 쌍 모음 (커플모임)

```js
let obj = {};
```

- 객체 `obj`가 생성되면, V8은 새로운 JS 객체를 생성하고 이에 메모리를 할당하는데,  
  이 때 `obj` 값은 이 객체에 대한 포인터임
  - 즉 `obj`가 태어나면, V8은 새로운 주민을 신고하고, 이를 인구수에 추가함 `obj`의 값은 주민등록증임

### 객체 구성 요소

- Map: 객체가 속한 히든 클래스에 대한 포인터

  - 히든 클래스: V8은 내부적으로 런타임 시, 객체에 대한 히든 클래스를 생성해 메타 정보 (출생정보)를 저장함
  - (관상같이) 속성을 수정할 수 있어, 히든 클래스를 미리 아는 것은 불가능.
  - 히든 클래스는 객체 모양에 대한 식별자 역할을 하므로 V8 최적화 컴파일러 및 인라인 캐시에 중요한 요소임

- Properties: 명명된 속성을 포함하는 객체에 대한 포인터, 객체 초기화 후 추가된 속성은 Properties store에 추가 됨
- Element: 번호가 매겨진 속성을 포함하는 객체에 대한 포인터
- In-Object Properties/Fast properties: 객체 초기화 시, 명명된 속성에 대한 포인터. 이때 속성 수는 객체에 따라 다름;

![Object_Memory](./images/스크린샷%202024-08-20%20오전%2010.29.48.png)

- V8이 이 객체에 대해 (8 + 8 + 8 + 8\*N) 바이트의 메모리 크기를 할당한다는 것을 알 수 있음
  - 사이트랑 다르게 난 48이 할당됨; (OS 혹은 V8 차이인 듯)

### in-object slack tracking

- 새로운 속성이 추가될 때마다, 객체를 재할당하기 싫음 ... 작은 객체에 큰 메모리 덩어리를 할당하는 건 공간낭비니깐,  
  그래서 V8은 적절한 공간 크기를 결정하기 위해 'in-object slack tracking'기능을 사용함

  - 주요 동작은 이럼, 주어진 생성자에 대해 V8은 해당 속성을 객체 내 속성으로 저장하기 넉넉한 양의 메모리를 할당하고,  
    동일한 생성자에서 특정 수의 객체를 할당한 후 v8은 객체의 전환 트리를 살펴보고 객체의 최대 크기를 확인해서,  
    최대 속성 수를 저장하기 충분한 새 객체에 할당함 (성장기 어린이 옷 맞추는 느낌 최대한 넉넉한 사이즈로 사서 커서도 입게 유도)

    - 초기 객체의 크기도 영리한 트릭을 사용해 조정됨.

      - 초기 객체 할당시, 해당 필드가 초기화되어 가비지 콜렉터에 여유 공간으로 표시되지만, 실제로 해당 객체를 여유 공간으로 처리하진 않음  
        그러나, slack tracking 프로세스가 끝나면 새 인스턴스 크기가 전환 트리 맵에 기록되어, 해당 맵이 있는 객체는 더 작아고,  
        사용되지 않는 필드는 이미 여유 공간처럼 보이기 때문에, 초기 객체를 수정할 필요가 없음

        - 처음엔 넉넉한 노트사고 끝까지 안적어서, 다시 노트를 구매할 필요가 없음

## 참고

- [How is data stored in V8 JS engine memory?](https://www.dashlane.com/blog/how-is-data-stored-in-v8-js-engine-memory)

- [A tour of V8: object representation](https://www.jayconrod.com/posts/52/a-tour-of-v8-object-representation)
